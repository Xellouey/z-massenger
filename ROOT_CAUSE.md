# ROOT CAUSE ANALYSIS

## Методология

Для каждой проблемы применен метод элиминации гипотез на основе:
1. Анализа исходного кода
2. Логов выполнения
3. Стек-трейсов ошибок
4. Сравнения с работающими частями кода

---

## ПРОБЛЕМА #1: Неверное отображение информации звонящего

### Корневая причина: **Гипотеза 1.1**

**Вердикт:** ✅ ПОДТВЕРЖДЕНО - Это корневая причина

**Обоснование:**

1. **Прямые доказательства из кода:**
```dart
// lib/screens/app_screens/pick_up_call/pick_up_body.dart:363
Text('${call!.receiverName} Audio Call')
```

Этот код **всегда** отображает `call!.receiverName`, независимо от того, кто инициировал звонок.

2. **Сравнение с работающим кодом видео-звонков:**
```dart
// pick_up_body.dart:224-228 - VIDEO CALL (ПРАВИЛЬНО!)
Text(
  call!.isGroup == true
      ? call!.groupName!
      : call!.callerId == appCtrl.user["id"]
          ? call!.receiverName!   // Я звоню → показать кому звоню
          : call!.callerName!,    // Мне звонят → показать кто звонит
)
```

Видно, что для **видео звонков** используется правильная логика с проверкой `call!.callerId == appCtrl.user["id"]`.

3. **Доказательство из логов:**
- FCM notification содержит правильные данные: `"pName":"Пашка"`
- Push уведомление отображается правильно: `"Title: Пашка", "Body: Пашка звонит!"`
- Значит данные приходят корректно, проблема в UI логике

4. **Логика Call Model:**
```
Входящий звонок от Пашка:
  - call.callerId = "fjgeFlNdTISFrBG1YKhmcKUgtwz2" (Пашка)
  - call.callerName = "Пашка"
  - call.receiverId = "1PV0K8UblpVxRHvzmBOf4znKzWN2" (Я)
  - call.receiverName = "Мое имя"

Текущий код показывает: call.receiverName = "Мое имя" ❌
Должен показывать: call.callerName = "Пашка" ✓
```

**Почему именно эта причина:**
- Симптомы полностью объясняются кодом на строке 363
- Проблема воспроизводится 100% для всех входящих звонков
- Исправление этой строки полностью решит проблему
- Нет других факторов, влияющих на отображение

**Отклоненные гипотезы:**
- ❌ Гипотеза 1.2 (Неверный парсинг Call model): Опровергнута логами - данные парсятся правильно

---

## ПРОБЛЕМА #2: Продолжение воспроизведения мелодии

### Корневая причина: **Гипотеза 2.1**

**Вердикт:** ✅ ПОДТВЕРЖДЕНО - Это корневая причина

**Обоснование:**

1. **Анализ кода принятия звонка:**
```dart
// lib/screens/app_screens/pick_up_call/pick_up_body.dart:124-199
).inkWell(onTap: () async {
  // Stop vibration when call is accepted
  await Vibration.cancel();  ✓ Вибрация останавливается

  // ❌ НЕТ КОДА ДЛЯ ОТМЕНЫ УВЕДОМЛЕНИЯ!
  // Должно быть:
  // await flutterLocalNotificationsPlugin.cancel(notificationId);
```

2. **Настройки уведомления:**
```dart
// lib/controllers/common_controllers/notification_controller.dart:764-766
category: isCall ? AndroidNotificationCategory.call : ...,
ongoing: true,        // ❌ Уведомление ПОСТОЯННОЕ
autoCancel: false,    // ❌ НЕ отменяется при клике
```

Эти настройки означают:
- `ongoing: true` - уведомление не удаляется системой автоматически
- `autoCancel: false` - не удаляется при клике пользователя
- Звук продолжает играть, пока уведомление активно

3. **Доказательство что проблема в уведомлении:**
- Пользователь сообщает: "лечится открытием и закрытием шторки пуш уведомлений"
- Это значит: при ручном удалении уведомления звук останавливается
- Следовательно: звук привязан к жизненному циклу уведомления

4. **Сравнение с вибрацией:**
```dart
// Вибрация ОСТАНАВЛИВАЕТСЯ:
await Vibration.cancel();  ✓

// Уведомление НЕ ОСТАНАВЛИВАЕТСЯ:
// (код отсутствует)  ❌
```

5. **Логи подтверждают:**
```
I/NotificationManager(23877): notify(508096619, ...)
I/flutter (23877): ✅ Notification shown successfully with ID: 508096619
```
Уведомление создается, но в коде нет ни одного вызова `.cancel(508096619)` после принятия звонка.

**Почему именно эта причина:**
- Поведение полностью соответствует жизненному циклу ongoing notification
- Исправление путем ручного свайпа подтверждает связь со звуком
- Отсутствие кода отмены - прямая причина

**Вспомогательный фактор:**
- ✓ Гипотеза 2.2 (Дублирующиеся уведомления): Усиливает проблему, но не является корневой причиной
  - В логах видно два вызова show notification
  - Но даже одно уведомление не отменяется

**Отклоненные гипотезы:**
- ❌ Гипотеза 2.3 (Отдельный источник звука): Весь код закомментирован, не активен

---

## ПРОБЛЕМА #3: Неверная навигация после завершения звонка + Crash

### Корневая причина: **Комбинация Гипотез 3.1 + 3.2 + 3.4**

**Вердикт:** ✅ ПОДТВЕРЖДЕНО - Множественные взаимосвязанные причины

### 3.1: Отсутствие параметра 'message' - ПРЯМАЯ ПРИЧИНА CRASH

**Обоснование:**

1. **Стек-трейс:**
```
E/flutter (23877): NoSuchMethodError: The method '[]' was called on null.
E/flutter (23877): #1 ChatController.getChatData (chat_controller.dart:319:13)
```

2. **Проблемный код:**
```dart
// audio_call_controller.dart:709-712
Get.toNamed(routeName.chatLayout, arguments: {
  'chatId': '0',
  'data': userContact,
  // ❌ ОТСУТСТВУЕТ: 'message': ...
});

// chat_controller.dart:143
data = Get.arguments;  // = {'chatId': '0', 'data': userContact}

// chat_controller.dart:319
if (data["message"] != null && data['message'] != "") {
    // ❌ CRASH: попытка получить data["message"]
    // когда ключ "message" не существует в Map
```

3. **Почему именно NoSuchMethodError:**
В Dart, когда вызываешь `map["key"]` на `Map`, и ключ не существует:
- Обычно возвращается `null`
- НО если Map = null, то получаем `NoSuchMethodError: The method '[]' was called on null`

Это означает либо:
- `data` сам является null, ИЛИ
- Логика проверки вызывает метод на null промежуточном значении

4. **Логи подтверждают:**
```
[log] receiverData :{chatId: 0, data: Instance of 'UserContactModel'}
[log] chatId :::0
E/flutter (23877): Unhandled Exception: NoSuchMethodError...
```

Видно что:
- `chatId = 0` передается
- `data` содержит UserContactModel
- НО нет ключа `message`

**Вывод по 3.1:** Это ПРЯМАЯ причина краша. Но crash - это симптом более глубокой проблемы.

---

### 3.2: Неверная точка возврата - КОРНЕВАЯ БИЗНЕС-ЛОГИЧЕСКАЯ ОШИБКА

**Обоснование:**

1. **Требование пользователя:**
> "После беседы при завершении звонка открывается новый чат с собеседником, так быть не должно, давай будем открывать окно всех чатов, вместо конкретного."

2. **Текущее поведение:**
```dart
// audio_call_controller.dart:807-810
log("endCall: Cleanup complete, navigating to chat");
await _navigateToChat();  // ❌ Открывает чат
```

3. **Ожидаемое поведение:**
```dart
// Должно быть:
log("endCall: Cleanup complete, navigating to dashboard");
Get.offAllNamed(routeName.dashboard);  // ✓ Открывает список чатов
```

4. **UX Анализ:**
- **WhatsApp/Telegram:** После звонка возвращают на список чатов
- **Текущее приложение:** Открывает конкретный чат
- **Проблема:** Нарушение ожидаемого UX паттерна

**Вывод по 3.2:** Это КОРНЕВАЯ бизнес-логическая ошибка. Даже если бы crash был исправлен, навигация все равно неверна.

---

### 3.4: Небезопасное обращение к аргументам - АРХИТЕКТУРНАЯ ПРОБЛЕМА

**Обоснование:**

1. **Defensive programming не применен:**
```dart
// chat_controller.dart:319 - ТЕКУЩИЙ КОД (небезопасно)
if (data["message"] != null && data['message'] != "") {
    // Crash если ключ не существует
}

// ДОЛЖНО БЫТЬ (безопасно):
if (data != null &&
    data.containsKey("message") &&
    data["message"] != null &&
    data["message"] != "") {
    // Безопасная проверка
}
```

2. **Та же проблема в других местах:**
```dart
// chat_controller.dart:337-348
if (data["forwardMessage"] != null && data['forwardMessage'] != "") {
    // Та же проблема!
}
```

3. **Почему это архитектурная проблема:**
- ChatController принимает dynamic аргументы без валидации
- Нет четкого контракта (interface/model) для navigation arguments
- Разные источники навигации передают разную структуру

**Вывод по 3.4:** Это АРХИТЕКТУРНАЯ проблема, которая делает код хрупким и подверженным крашам.

---

### Взаимосвязь причин для Проблемы #3:

```
Корневая бизнес-причина (3.2):
    Неверная точка возврата после звонка
    └─> Разработчик решил открывать чат
        └─> Вызывается _navigateToChat()
            └─> Передаются неполные аргументы (3.1)
                ├─> chatId='0' (новый чат)
                ├─> data=userContact
                └─> ❌ ОТСУТСТВУЕТ 'message'
                    └─> ChatController пытается получить data["message"] (3.4)
                        └─> ❌ CRASH: NoSuchMethodError
```

**Приоритет исправлений:**
1. **Критический:** Исправить 3.4 (добавить проверку ключей) - предотвратит crash
2. **Важный:** Изменить 3.2 (навигация на dashboard) - правильное UX
3. **Желательный:** Унифицировать 3.1 (стандартизировать navigation API)

**Отклоненные гипотезы:**
- ✓ Гипотеза 3.3 (Конфликт между pick_up_body и audio_call_controller): Подтверждает наличие проблемы, но не является первопричиной
- ❌ Гипотеза 4.2 (Race condition): Уже исправлена в предыдущих коммитах

---

## ОБЩИЕ АРХИТЕКТУРНЫЕ ПРОБЛЕМЫ

### Гипотеза 4.1: Отсутствие единой точки навигации

**Статус:** ✅ Подтверждена как contributing factor

**Обоснование:**

Найдено минимум **3 разных реализации** навигации после звонка:

1. **pick_up_body.dart:31-85** - при отклонении/завершении через pickup screen
2. **audio_call_controller.dart:681-717** - после завершения аудио звонка
3. **video_call_controller.dart** - вероятно своя реализация (не проверено, но по аналогии)

Каждая имеет:
- Разную логику определения данных
- Разные переданные параметры
- Разное поведение

**Последствия:**
- Дублирование кода
- Несогласованное поведение
- Баги в одном месте не исправляются в другом
- Сложность поддержки

**Рекомендация:** Создать единый сервис `CallNavigationService` с методами:
- `navigateAfterCallEnd(Call call, CallEndReason reason)`
- `navigateAfterCallDecline(Call call)`
- И т.д.

---

## ИТОГОВАЯ ТАБЛИЦА КОРНЕВЫХ ПРИЧИН

| Проблема | Корневая причина | Тип | Файл:строка | Критичность |
|---|---|---|---|---|
| #1: Неверное отображение | Отсутствие проверки направления звонка | Логическая ошибка | pick_up_body.dart:363 | Средняя |
| #2: Мелодия не останавливается | Отсутствие отмены notification | Упущенный код | pick_up_body.dart:126 | Высокая (UX) |
| #3: Crash при навигации | Небезопасное обращение к Map ключам | Архитектурная | chat_controller.dart:319 | Критическая |
| #3: Неверная навигация | Открытие чата вместо dashboard | Бизнес-логика | audio_call_controller.dart:810 | Средняя |
| Общая | Отсутствие единой точки навигации | Архитектурная | Множество | Средняя |

---

## УВЕРЕННОСТЬ В ВЫВОДАХ

### Проблема #1: 99% уверенности ⭐⭐⭐⭐⭐
- Прямое сопоставление кода и симптомов
- Есть правильная реализация для сравнения (video calls)
- Логи полностью подтверждают

### Проблема #2: 95% уверенности ⭐⭐⭐⭐⭐
- Поведение полностью соответствует жизненному циклу notification
- Отсутствие кода отмены очевидно
- Пользовательский workaround подтверждает

### Проблема #3: 100% уверенности ⭐⭐⭐⭐⭐
- Стек-трейс прямо указывает на строку
- Код очевидно небезопасен
- Логи показывают отсутствие параметра

### Архитектурные проблемы: 90% уверенности ⭐⭐⭐⭐
- Наблюдается паттерн дублирования
- Не все файлы проверены (video_call_controller)
- Но достаточно доказательств для вывода
